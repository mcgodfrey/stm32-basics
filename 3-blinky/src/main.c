/*
# Control LED brightness with PWM

Uses the PWM output from TIM3 to pulse LED brightness.
3 LEDs are connected to 3 PWM output channels (4th is unused).
The main loop then ramps the duty cycle of each channel/LED separately so that they pulse at different rates.

Note: PWM outputs are hard wired to certain pins in the chip, and so cannot use the onboard LEDs.
You need to wire 3 LEDs + current limiting resistors to:
 - PORTA_6
 - PORTA_7
 - PORTB_0

This example is slightly more involved and uses an MSP function call (MCU Support Package - ie. MCU specific initialisation code).
The PWM init code sets up the timer and output compare registers which is all common across all of the stm32 controllers.
But the output pin mapping for different peripherals can change for different controllers.
So the idea is to move that code out into a separate MSP function call so that when changing controllers, only the MSP code needs to be changed.

In this case, the standard HAL function HAL_TIM_PWM_Init() looks for a function (which I have to define) called HAL_TIM_Base_MspInit().
This is defined in a separate c-file stm32f4x_hal_msp_template.c

This works by overriding a default MspInit definition included in the libary code using weak linkage (https://blog.feabhas.com/2013/01/weak-linkage-in-c-programming/)
Basically, the default definition included in the libary is defined as __weak which tells the linker that if another definition is provided then use that instead.
*/
#include "stm32f4xx.h"
#include "stm32f4_discovery.h"

/* Global timer3 object.
 * This is accessed in initialisation, and in callback functions/interrupts
 */
TIM_HandleTypeDef htim3;

void GPIO_Init(void);
void SystemClock_Config(void);
void PWM_Init(void);


int main(void)
{
	/* Must be called first at the start of any code using the HAL library */
	HAL_Init();
	/* Set up the system clock (note: autogenerated code from STCubeMX */
	SystemClock_Config();
	/* Setup the onboard LED4. The PWM output pins are set up in PWM_Init */
	GPIO_Init();
	/* Set up the timer and PWM output pins */
	PWM_Init();

	/* Start the timer and enable PWM outputs */
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);

    /*
     * The main loop here modulates the brightness/duty_cycle of the LEDs.
     * Note the PWM output is driven by the hardware, and so will continue automatically from here
     *   The main loop here is only needed to pulse the brightness
     * I basically hard code 3 different ramp rates for the duty_cycle for each of the 3 channels
     *   It increments the duty cycle of each up to a maximum of 65000 (near timer overflow for 16bit timer)
     *   and then back down to zero.
     */
	unsigned int inc[] = {200, 500, 1000};
	unsigned int pulse_width[] = {0, 0, 0};
	int direction[] = {1, 1, 1};
	unsigned char channel[] = {TIM_CHANNEL_1, TIM_CHANNEL_2, TIM_CHANNEL_3};

	while(1){
		/* Loop through each of the 3 output channels */
		for(int i=0; i<3; i++){
			if(pulse_width[i] > 65000-2*inc[i]){
				direction[i] = -1;
			}else if(pulse_width[i] < 2*inc[i]){
				direction[i] = 1;
			}
			pulse_width[i] += direction[i]*inc[i];		// calculate the new duty cycle
			__HAL_TIM_SET_COMPARE(&htim3, channel[i], pulse_width[i]);	//update the duty cycle
		}

		/* Toggle the onboard LED for debugging */
		HAL_GPIO_TogglePin(LED4_GPIO_PORT, LED4_PIN);
		HAL_Delay(5);	//Small delay to slow down the pulsing
	}
}



/*
 * Setup the onboard LED4 on the discovery board as an output
 * The macros/function and pin numbers/ports (eg. LED4_PIN, LED4_GPIO_PORT)
 *   are defined in Utilities/STM32F4-Discovery/stm43f4_discovery.c
 *
 *   Basically, there are 2 steps:
 *    - Enable the GPIO clock for each Port
 *    	eg. __HAL_RCC_GPIOD_CLK_ENABLE();
 *    - Create a GPIO_InitTypeDef structure with the initialisation configuration for each pin
 *      - Pass this struct to HAL_GPIO_INIT function to set up each pin.
 *      eg. HAL_GPIO_Init(LED4_GPIO_PORT, &GPIO_InitStructure);
 */
void GPIO_Init(void){
	/* Create an InitStructure to hold the initialisation configuration for each pin */
	GPIO_InitTypeDef GPIO_InitStructure;

	// enable the GPIO clock
    LED4_GPIO_CLK_ENABLE();

	// Setup LED pin as an output
	GPIO_InitStructure.Pin = LED3_PIN;
	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;	// Push-pull mode
	GPIO_InitStructure.Pull = GPIO_NOPULL;			// no pullup resistors
	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW; // low frequency - not important for this example.
    HAL_GPIO_Init(LED4_GPIO_PORT, &GPIO_InitStructure);
}



/*
 * Set up the TIM3 timer to generate PWM signals on channels 1, 2, 3
 * Set the timer to count up mode, no prescaler or clock division to it runs at max speed
 *   Speed is determined by the internal clock setup, which is set in SystemClock_Config()
 *   It doesn't really matter what it is here, as long as it is fast so there is no flicker
 *
 * Then set the clock config and master/slave synchronisation, the same as previous examples.
 *
 * Then set the PWM parameters for each channel.
 * Initially set all duty cycles (sConfigOC.Pulse) to zero. This will be adjusted later in the main loop.
 *
 * Finally, call HAL_TIM_PWM_Init - this doesn't really do much, but it does call my HAL_TIM_Base_MspInit() function. See next point.
 *
 * Note that this function doesn't directly set the output pins/GPIO.
 * That is handled by the MSP (MCU Support Package - ie. MCU specific initialisation code) function which is called from HAL_TIM_PWM_Init()
 *   Note that function is defined in stm32f4xx_hal_msp_template.c and called HAL_TIM_Base_MspInit()
 *   It sets the pins to outputs and sets them to alternate-function, etc.
 *   The reason it is split out is that the GPIO code is potentially microcontroller specific - ie. if
 *     pwm outputs are mapped to different pins on different controllers
 */
void PWM_Init(void){
	// Enable the output port clocks
	__HAL_RCC_GPIOB_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();

    TIM_ClockConfigTypeDef sClockSourceConfig;
    TIM_MasterConfigTypeDef sMasterConfig;
    TIM_OC_InitTypeDef sConfigOC;

    // Set up the timer to count up to 64000, max speed (no dividers or prescalers)
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = 0;
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 64000;
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim3);

    //Set up the clock config to use the internal clock
    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
    HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);

    // Clock synchronisation/master/slave config
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);

    // Set up the pwm on each channel (initially all with duty cycle of zero)
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 0;
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);

    // PWM init
    HAL_TIM_PWM_Init(&htim3);
}



/*
 * Set up 32MHz clock
 * This was generated with STMCubeMX tool
 */
void SystemClock_Config(void)
{

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage
    */
  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    /**Initializes the CPU, AHB and APB busses clocks
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 64;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

    /**Initializes the CPU, AHB and APB busses clocks
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);

    /**Configure the Systick interrupt time
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);

    /**Configure the Systick
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
}
